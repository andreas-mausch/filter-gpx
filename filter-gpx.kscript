#!/usr/bin/env kscript

@file:DependsOn("io.jenetics:jpx:1.5.2")
@file:DependsOn("commons-cli:commons-cli:1.4")

import io.jenetics.jpx.*
import java.time.*
import java.time.Duration.between
import org.apache.commons.cli.*

enum class GroupBy {
    DAY, MONTH
}

data class Box(val latitudeLeft: Double, val latitudeRight: Double, val longitudeTop: Double, val longitudeBottom: Double) {
    companion object {
        fun from(topleft: String, bottomright: String): Box {
            fun split(coordinates: String): Pair<Double, Double> {
                return coordinates.split(",").map { it.toDouble() }.zipWithNext().first()
            }

            val topleftPair = split(topleft)
            val bottomrightPair = split(bottomright)
            return Box(bottomrightPair.first, topleftPair.first, topleftPair.second, bottomrightPair.second)
        }
    }
}

fun parseArguments(): CommandLine {
    val parser: CommandLineParser = DefaultParser()

    val topleft = Option.builder("tl")
        .longOpt("topleft")
        .hasArg()
        .required()
        .type(String::class.java)
        .valueSeparator()
        .desc("Top-left coordinates of the bounding box. E.g. 53.123,10.543")
        .build()
    val bottomright = Option.builder("br")
        .longOpt("bottomright")
        .hasArg()
        .required()
        .type(String::class.java)
        .valueSeparator()
        .desc("Bottom-right coordinates of the bounding box. E.g. 53.123,10.543")
        .build()
    val groupBy = Option.builder("g")
        .longOpt("groupBy")
        .hasArg()
        .type(GroupBy::class.java)
        .valueSeparator()
        .desc("Group by either DAY or MONTH")
        .build()

    val options = Options()
    options.addOption(topleft)
    options.addOption(bottomright)
    options.addOption(groupBy)

    try {
        val commandLine = parser.parse(options, args)
        if (commandLine.argList.size != 1) {
            throw ParseException("No filename provided.")
        }
        return commandLine
    } catch (e: ParseException) {
        val formatter = HelpFormatter()
        formatter.printHelp("filter-gpx.kscript [options] <gpx.file>", options)
        kotlin.system.exitProcess(-1)
    }
}

fun isInArea(point: Point, box: Box): Boolean {
    return point.latitude.toDouble() >= box.latitudeLeft
        && point.latitude.toDouble() <= box.latitudeRight
        && point.longitude.toDouble() >= box.longitudeTop
        && point.longitude.toDouble() <= box.longitudeBottom
}

fun durationInArea(points: List<Point>, box: Box): List<Pair<Point,Point>> {
    val sortedPoints = points.toMutableList()
    sortedPoints.sortBy { it.time.get() }

    var entryPoint: Point? = null
    var pairs = mutableListOf<Pair<Point, Point>>()

    sortedPoints.forEach {
        if (entryPoint == null && isInArea(it, box)) {
            entryPoint = it
        } else if (entryPoint != null && !isInArea(it, box)) {
            pairs.add(Pair(entryPoint!!, it))
            entryPoint = null
        }
    }

    if (entryPoint != null) {
        pairs.add(Pair(entryPoint!!, sortedPoints.last()))
    }

    return pairs
}

fun group(by: GroupBy): (Point) -> LocalDate {
    return { it.time.get().toLocalDate() }
}

fun Iterable<Duration>.sum(): Duration {
    return this.fold(Duration.ofSeconds(0)) { sum, element -> sum.plus(element) }
}

val commandLine = parseArguments()
val filename = commandLine.argList.first()
val box = Box.from(commandLine.getOptionValue("topleft"), commandLine.getOptionValue("bottomright"))
val groupBy = commandLine.getOptionValue("groupBy")?.let { GroupBy.valueOf(it) } ?: GroupBy.DAY

val track = GPX.reader(GPX.Version.V10, GPX.Reader.Mode.LENIENT)
               .read(filename)
               .tracks
               .filter { it.name.isPresent() && it.name.get() == "SM-G973F" }

val points = track.flatMap { it.segments }.flatMap { it.points }
val groupedByDate = points.groupBy(group(groupBy))

groupedByDate.forEach {
    val pairs = durationInArea(it.value, box)
    val duration = pairs.map { between(it.first.time.get(), it.second.time.get()) }.sum()
    println("${it.key}: ${duration} (${it.value.size} Points)")
}
